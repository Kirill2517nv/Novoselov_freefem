
real xMin = -10.0;
real xMax = 10.0;
real yMin = -5.0;
real yMax = 5.0;

real xMidLeft = -5.0;
real xMidRight = 5;
real xMid = 0;
real yMid = 0;


int LabelIn = 1;
int LabelOut = 2;


int Nin = 3 * 32; 
int Nout = Nin * 8;


border GammaLT1( t = 0.0, 1) {
    x = xMin + (xMidLeft - xMin) * t;
    y = x + 10;
    label = LabelIn;
}

border GammaLT2( t = 0.0, 1) {
    x = xMidLeft + (xMid - xMidLeft) * t;
    y = 0.48 * x^2 + 2.4 * x + 5;
    label = LabelIn;
}

border GammaRT1( t = 0.0, 1) {
    x = xMid +(xMidRight - xMid) * t;
    y = 0.48 * x^2 - 2.4 * x + 5;
    label = LabelIn;
}

border GammaRT2( t = 0.0, 1) {
    x = xMidRight +(xMax - xMidRight) * t;
    y = 10 - x;
    label = LabelIn;
}

border GammaLB1( t = 0.0, 1) {
    x = xMidLeft +(xMin - xMidLeft) * t;
    y = -x - 10;
    label = LabelIn;
}

border GammaLB2( t = 0.0, 1) {
    x = xMid + (xMidLeft - xMid) * t;
    y = -0.48 * x^2 - 2.4 * x - 5;
    label = LabelIn;
}

border GammaRB1( t = 0.0, 1) {
    x = xMidRight + (xMid - xMidRight) * t;
    y = -0.48 * x^2 + 2.4 * x - 5;
    label = LabelIn;
}

border GammaRB2( t = 0.0, 1) {
    x = xMax + (xMidRight - xMax) * t;
    y = x - 10;
    label = LabelIn;
}

border GammaOut( t = 0.0, 2*pi) {
    x = 11 * cos(t);
    y = 8 * sin(t);
    label = LabelOut;
}

mesh Th = buildmesh(GammaLT1(Nin) + GammaLT2(Nin) + GammaRT1(Nin) + GammaRT2(Nin) +
                    GammaLB1(Nin) + GammaLB2(Nin) + GammaRB1(Nin) + GammaRB2(Nin) +
                    GammaOut(Nout));

/*  plot(Th); */


fespace Vh(Th, P1); 


real w = 0.01;
func uExactFunc = sin(w*(x + y^2));
func f = w*w*(1 + 4*y^2) * sin(w*(x + y^2)) - 2 * w* cos(w*(x + y^2));
func ux1 = w*cos(w*(x + y^2));
func uy1 = 2 * y * w * cos(w*(x + y^2));


Vh u,v;
Vh uExact = uExactFunc; 
Vh ff = f;
Vh ux = ux1;
Vh uy = uy1;
Vh h = hTriangle;
verbosity = 0;



varf PoissonBilinearForm (u,v) = 
    int2d(Th)(
        dx(u) * dx(v) + dy(u) * dy(v)
    )
    + on(LabelIn, u = uExact)
    ;

/* Linear form defenition for rhs */
varf RhsLinearForm(u,v) = 
    int1d(Th, LabelOut)( (ux * N.x + uy * N.y) * v)
    + int2d(Th)(ff * v )
    + on(LabelIn, u = uExact)
    ;

matrix A = PoissonBilinearForm(Vh, Vh);
real[int] b = RhsLinearForm(0, Vh);

u[] = A^-1 * b; 

Vh uErrorAbs = abs(u - uExact);

real error = 0.001;
real nvertices = 200000;
real hMin = 0.0001;
real hMax = 0.1;

for(int i = 0; i < 6 ; i++){

    Th = adaptmesh( Th,u, 
            err = error, /* Interpolation P1 error */
            nbvx = nvertices, /* MAx vertices noumber */
            hmin = hMin, /* min edge size */
            hmax = hMax, /* max rdge size */
            iso = true /* is metric isotropic? */
    );
    v = v;
    u = u;
    ff = f;
    ux = ux1;
    uy = uy1;
    uExact = uExactFunc;
    uErrorAbs = abs(u - uExact);
    matrix A = PoissonBilinearForm(Vh, Vh);
    real[int] b = RhsLinearForm(0, Vh); 
    u[] = A^-1 * b; 
    error = error/2;
    string plotTitle = "Poisson Solution " + i;
    plot(Th, u, fill = 0 , dim = 2, wait = 1, value = 1, nbiso = 30,cmm = plotTitle);
    /* Error in L2 norm calculation*/
    real uErorL2Norm = sqrt( int2d(Th)((uErrorAbs)^2));
    /*  L2 norm u*/
    real uL2Norm = sqrt( int2d(Th)((u)^2));
    /*  L2 norm uExact */
    real uExactL2Norm = sqrt( int2d(Th)(uExact^2));
    /*  Relative uError */
    real uErrorRelL2Norm = uErorL2Norm / uExactL2Norm;
    cout<<" ======= parametrs, when we know uExact ======="<< endl;
    cout << "||uEror||_L2 " << uErorL2Norm << endl;
    cout << "||uErorRel||_L2 " << uErrorRelL2Norm << endl;
}









