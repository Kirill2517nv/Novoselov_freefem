real xMin = -10.0;
real xMax = 10.0;
real yMin = -5.0;
real yMax = 5.0;

real xMidLeft = -5.0;
real xMidRight = 5;
real xMid = 0;
real yMid = 0;


int LabelLT1 = 1;
int LabelLT2 = 2;
int LabelRT1 = 3;
int LabelRT2 = 4;
int LabelLB1 = 5;
int LabelLB2 = 6;
int LabelRB1 = 7;
int LabelRB2 = 8;
int LabelOut = 9;

int NN = 50;
int Nin = NN; 
int Nout = NN * 8;



func uExactFunc = sin(x*x + y*y);
func f = (4*x*x + 4*y*y) * sin(x*x + y*y) - 4 * cos(x*x + y*y);



border GammaLT1( t = 0.0, 1) {
    x = xMin +(xMidLeft-xMin)*t;
    y = x + 10;
    label = LabelLT1;
}

border GammaLT2( t = 0.0, 1) {
    x = xMidLeft +(xMid-xMidLeft)*t;
    y = 0.48*x^2 + 2.4*x + 5;
    label = LabelLT2;
}

border GammaRT1( t = 0.0, 1) {
    x = xMid +(xMidRight-xMid)*t;
    y = 0.48*x^2 - 2.4*x + 5;
    label = LabelRT1;
}

border GammaRT2( t = 0.0, 1) {
    x = xMidRight +(xMax-xMidRight)*t;
    y = 10 - x;
    label = LabelRT2;
}

border GammaLB1( t = 0.0, 1) {
    x = xMidLeft +(xMin -xMidLeft)*t;
    y = -x - 10;
    label = LabelLB1;
}

border GammaLB2( t = 0.0, 1) {
    x = xMid +(xMidLeft - xMid)*t;
    y = -0.48*x^2 - 2.4*x - 5;
    label = LabelLB2;
}

border GammaRB1( t = 0.0, 1) {
    x = xMidRight +(xMid - xMidRight)*t;
    y = -0.48*x^2 + 2.4*x - 5;
    label = LabelRB1;
}

border GammaRB2( t = 0.0, 1) {
    x = xMax +(xMidRight - xMax)*t;
    y = x - 10;
    label = LabelRB2;
}

border GammaOut( t = 0.0, 2*pi) {
    x = 11 * cos(t);
    y = 8 * sin(t);
    label = LabelOut;
}


plot(GammaLT1(Nin) + GammaLT2(Nin) + GammaRT1(Nin) + GammaRT2(Nin) +
     GammaLB1(Nin) + GammaLB2(Nin) + GammaRB1(Nin) + GammaRB2(Nin) +
     GammaOut(Nout));


mesh Th = buildmesh(GammaLT1(Nin) + GammaLT2(Nin) + GammaRT1(Nin) + GammaRT2(Nin) +
                    GammaLB1(Nin) + GammaLB2(Nin) + GammaRB1(Nin) + GammaRB2(Nin) +
                    GammaOut(Nout));

plot(Th);

fespace Vh(Th, P1); 

Vh h = hTriangle;

Vh u,v;
Vh uExact = uExactFunc; 
Vh ff = f;


varf LaplaceBilinearForm (u,v) = 
    int2d(Th)(
        dx(u)*dx(v) + dy(u)*dy(v)
    )
    + on(LabelOut, u = uExact)
    ;

/* Linear form defenition for rhs */

func g = dx(uExact) * N.x + dy(uExact) * N.y;

varf RhsLinearForm(u,v) = 
    int2d(Th)(
        (-ff) * v
    )
    + int1d(Th, LabelLT1)( g * v)
    + int1d(Th, LabelLT2)( g * v)
    + int1d(Th, LabelRT1)( g * v)
    + int1d(Th, LabelRT2)( g * v)
    + int1d(Th, LabelLB1)( g * v)
    + int1d(Th, LabelLB2)( g * v)
    + int1d(Th, LabelRB1)( g * v)
    + int1d(Th, LabelRB2)( g * v)
    + on(LabelOut, u = uExact)
    ;

matrix A = LaplaceBilinearForm(Vh, Vh);
real[int] b = RhsLinearForm(0, Vh);

u[] = A^-1*b; 

string plotTitle = "Laplace Solution";

plot(Th, u, fill = true, dim = 2, value = 1, nbiso = 10, cmm = plotTitle);
plot(Th, uExact, fill = true, dim = 2, value = 1, nbiso = 10);


Vh uErrorAbs = abs((u - uExact) / uExact);

plot(Th, uErrorAbs, fill=true, dim = 3, value = 1, nbiso = 10);

/* Error in L2 norm calculation*/
real uErorL2Norm = sqrt( int2d(Th)(uErrorAbs^2));
real uExactL2Norm = sqrt( int2d(Th)(uExact^2));
real uErrorRelL2Norm = uErorL2Norm / uExactL2Norm;



cout << "size of mesh = " << h[].max << endl;
cout << "||uEror||_L2 " << uErorL2Norm << endl;
cout << "||uErorRel||_L2 " << uErrorRelL2Norm << endl;
